import os
import json
from typing import Dict, List, Optional, Union, Tuple
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from neo4j import GraphDatabase
from neo4j.exceptions import CypherSyntaxError
from crewai import Agent, Task, Crew
from crewai.tools import tool
import logging
import time

# --- Configuration ---
load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
# Use a more capable model if possible for complex Cypher generation and analysis
LLM_MODEL = os.getenv("LLM_MODEL", "gpt-4o") #"gpt-3.5-turbo" might struggle
NEO4J_URI = os.getenv("NEO4J_URI", "bolt://localhost:7687")
NEO4J_USER = os.getenv("NEO4J_USER", "neo4j")
NEO4J_PASSWORD = os.getenv("NEO4J_PASSWORD", "Javadad6908") # Make sure this matches your env or is correct

# --- Logging ---
# Increased logging level for crewai verbosity, adjust as needed
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s')
logger = logging.getLogger(__name__)
logging.getLogger('httpx').setLevel(logging.WARNING) # Quieten noisy libraries if needed
logging.getLogger('crewai').setLevel(logging.INFO)


# --- LLM Initialization ---
try:
    llm = ChatOpenAI(model_name=LLM_MODEL, temperature=0.2, openai_api_key=OPENAI_API_KEY) # Lower temp for more deterministic cypher/analysis
    logger.info(f"Using LLM: {llm.model_name}")
except Exception as e:
    logger.critical(f"Failed to initialize LLM: {e}")
    exit(1)

# --- Knowledge Graph Handler ---
class Neo4jKnowledgeGraph:
    _driver = None # Class level driver

    @classmethod
    def get_driver(cls, uri: str, user: str, password: str):
        """Gets a Neo4j driver instance, reusing if possible."""
        if cls._driver is None:
            try:
                cls._driver = GraphDatabase.driver(uri, auth=(user, password))
                cls._driver.verify_connectivity()
                logger.info(f"Neo4j driver initialized for URI: {uri}")
            except Exception as e:
                logger.critical(f"Failed to create Neo4j driver: {e}")
                cls._driver = None # Ensure driver is None if connection fails
                raise # Re-raise the exception to be caught downstream
        return cls._driver

    @classmethod
    def close_driver(cls):
        """Closes the Neo4j driver connection."""
        if cls._driver:
            cls._driver.close()
            cls._driver = None
            logger.info("Closed Neo4j driver connection.")

    @classmethod
    def execute_cypher_query(cls, query: str, params: Optional[dict] = None, retries: int = 2, delay: int = 1) -> Union[List[Dict], Dict[str, str]]:
        """Executes a Cypher query with retry logic and clearer error reporting."""
        driver = cls.get_driver(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)
        if not driver:
            return {"error": "Neo4j connection not available."}

        for attempt in range(retries):
            try:
                with driver.session() as session:
                    result = session.run(query, params or {})
                    records = [dict(record) for record in result]
                    logger.info(f"Cypher query executed successfully (Attempt {attempt + 1}). Query: '{query}', Parameters: {params}, Records returned: {len(records)}")
                    return records
            except CypherSyntaxError as e:
                error_message = f"Cypher Syntax Error: {e}. Query: '{query}', Parameters: {params}"
                logger.error(error_message)
                return {"error": error_message} # Don't retry syntax errors
            except Exception as e:
                logger.error(f"Error executing Cypher query (attempt {attempt + 1}/{retries}): {e}. Query: '{query}', Parameters: {params}")
                if attempt < retries - 1:
                    time.sleep(delay * (attempt + 1)) # Exponential backoff
                else:
                    return {"error": f"Failed to execute Cypher query after {retries} attempts: {e}. Query: '{query}'"}
        # Fallback if loop finishes unexpectedly
        return {"error": "Query execution failed unexpectedly."}


# --- Tool Definitions ---
# Tool for executing the Cypher query generated by the Query Constructor Agent
@tool("Execute Cypher Query Tool")
def execute_cypher_query_tool(query_info: str) -> Union[List[Dict], Dict[str, str]]:
    """
    Executes a given Cypher query with parameters against the Neo4j database.
    Input must be a JSON string containing 'query' (string) and 'params' (dict, optional).
    Returns the list of result records (dictionaries) or an error dictionary.
    Example input: '{"query": "MATCH (m:Microbe {name: $name}) RETURN m.abundance", "params": {"name": "E. coli"}}'
    """
    try:
        data = json.loads(query_info)
        query = data.get("query")
        params = data.get("params")

        if not query or not isinstance(query, str):
            return {"error": "Invalid input: 'query' field is missing or not a string."}
        if params is not None and not isinstance(params, dict):
             return {"error": "Invalid input: 'params' field must be a dictionary if provided."}

        logger.info(f"Executing Cypher via tool. Query: {query}, Params: {params}")
        return Neo4jKnowledgeGraph.execute_cypher_query(query, params)
    except json.JSONDecodeError:
        return {"error": "Invalid input: Input must be a valid JSON string."}
    except Exception as e:
        logger.error(f"Error in execute_cypher_query_tool wrapper: {e}")
        return {"error": f"Unexpected error processing query input: {e}"}

# Optional: Tool to get graph schema
@tool("Get Graph Schema Tool")
def get_graph_schema_tool(_) -> Dict[str, List[str]]:
    """
    Retrieves the basic schema of the Neo4j graph, including node labels, relationship types,
    and properties for Microbe, Metabolite, and Pathway nodes.
    Input is ignored (can be empty string or None).
    """
    schema = {
        "node_labels": [],
        "relationship_types": [],
        "properties": {}
    }
    try:
        # Get labels
        labels_result = Neo4jKnowledgeGraph.execute_cypher_query("CALL db.labels() YIELD label RETURN collect(label) as labels")
        if isinstance(labels_result, list) and labels_result:
            schema["node_labels"] = labels_result[0].get("labels", [])

        # Get relationship types
        rel_types_result = Neo4jKnowledgeGraph.execute_cypher_query("CALL db.relationshipTypes() YIELD relationshipType RETURN collect(relationshipType) as relTypes")
        if isinstance(rel_types_result, list) and rel_types_result:
            schema["relationship_types"] = rel_types_result[0].get("relTypes", [])

        # Get properties for specific labels (adjust labels as needed)
        for label in ["Microbe", "Metabolite", "Pathway"]:
            if label in schema["node_labels"]:
                 # This query might be slow on large graphs, consider sampling
                props_query = f"""
                    MATCH (n:{label})
                    WITH keys(n) AS keys
                    UNWIND keys AS key
                    RETURN collect(distinct key) as properties
                    LIMIT 1
                """
                props_result = Neo4jKnowledgeGraph.execute_cypher_query(props_query)
                if isinstance(props_result, list) and props_result:
                    schema["properties"][label] = props_result[0].get("properties", [])

        logger.info(f"Retrieved graph schema: {schema}")
        return schema
    except Exception as e:
        logger.error(f"Failed to retrieve graph schema: {e}")
        return {"error": f"Failed to retrieve schema: {e}"}

# --- Schema Definition (Provide directly to LLM if not using schema tool) ---
# This is crucial for the Query Constructor Agent
GRAPH_SCHEMA_DESCRIPTION = """
The knowledge graph contains information about microbial interactions.

Key Node Labels:
- Microbe: Represents a microbial strain.
  - Properties:
    - name (string, unique identifier)
    - abundance (float, optional, relative presence of the microbe)
- Metabolite: Represents a chemical compound involved in interactions.
  - Properties:
    - name (string, unique identifier)
- Pathway: Represents a biological pathway microbes are involved in.
  - Properties:
    - name (string, unique identifier)

Key Relationship Types (with properties):
- [:PRODUCES] - (Microbe)-[:PRODUCES {flux: float, description: str}]->(Metabolite)
- [:CONSUMES] - (Metabolite)-[:CONSUMES {flux: float, description: str}]->(Microbe) # Note: Relationship direction in graph storage. Query typically reverses: (Microbe)<-[:CONSUMES]-(Metabolite)
- [:CROSS_FEEDS_WITH] - (Microbe)-[:CROSS_FEEDS_WITH {source_biomass: float, target_biomass: float}]->(Microbe)
- [:INVOLVED_IN] - (Microbe)-[:INVOLVED_IN {subsystem_score: float, description: str}]->(Pathway)

Important Considerations for Queries:
- Always use parameters ($param_name) for node names or other values in WHERE clauses for security and efficiency.
- **Case Sensitivity**: Node name properties (e.g., Metabolite.name, Microbe.name) might have inconsistent capitalization. To ensure reliable matching regardless of case, **always use the `toLower()` function** on both the property and the parameter when matching names. Example: `WHERE toLower(met.name) = toLower($name)`.
- When searching for microbes related to a metabolite, consider both PRODUCES and CONSUMES relationships.
- Flux values indicate the rate of production/consumption. Higher flux might indicate higher importance.
- Abundance represents the relative presence of a microbe (if available).
- Subsystem score represents the importance of a pathway to a microbe.

Specific Query Patterns (Using Case-Insensitive Matching):
- To find entities doing *both* A and B (e.g., produce AND consume a specific metabolite):
  MATCH (met:Metabolite) WHERE toLower(met.name) = toLower($name) // Case-insensitive match first
  WITH met // Pass the matched metabolite
  MATCH (m:Microbe)-[:PRODUCES]->(met)
  MATCH (m)<-[:CONSUMES]-(met) // Find microbes with both relationships to 'met'
  RETURN m.name

- To calculate net values (e.g., net flux = production - consumption) for microbes doing *both*:
  MATCH (met:Metabolite) WHERE toLower(met.name) = toLower($name) // Case-insensitive match first
  WITH met
  MATCH (m:Microbe)-[p:PRODUCES]->(met)
  MATCH (m)<-[c:CONSUMES]-(met)
  RETURN m.name, p.flux AS production_flux, c.flux AS consumption_flux, (p.flux - c.flux) AS net_flux

- To handle cases where production or consumption might be missing (find microbes doing *either or both*), use OPTIONAL MATCH and COALESCE:
  MATCH (met:Metabolite) WHERE toLower(met.name) = toLower($name) // Case-insensitive match first
  WITH met
  MATCH (m:Microbe) // Consider adding WHERE clause if microbe list is too large
  OPTIONAL MATCH (m)-[p:PRODUCES]->(met)
  OPTIONAL MATCH (m)<-[c:CONSUMES]-(met)
  // Filter for microbes that have at least one interaction with the metabolite
  WHERE p IS NOT NULL OR c IS NOT NULL
  WITH m, met, COALESCE(p.flux, 0.0) AS production_flux, COALESCE(c.flux, 0.0) AS consumption_flux
  RETURN m.name, production_flux, consumption_flux, (production_flux - consumption_flux) AS net_flux
  ORDER BY net_flux DESC // Example ordering

Ensure all variables used in RETURN or calculations are defined in the preceding MATCH or WITH clauses. Use WITH clauses effectively to pass variables between MATCH clauses.
"""

# --- Agent Definitions ---
class MicrobialAnalysisPipeline:
    def __init__(self):
        self.llm = llm # Use the globally defined LLM

        # Define agents with improved roles, backstories, and tools
        self.query_constructor = Agent(
            role="Expert Neo4j Cypher Query Generator for Microbial Interactions",
            goal=f"""
                 Based on the user's question and the known graph schema, construct the most precise and efficient Cypher query(ies)
                 to retrieve the necessary data from the Neo4j knowledge graph.
                 Output MUST be a JSON string containing the 'query' and 'params' keys.
                 Example output format: '{{"query": "MATCH (m:Microbe {{name: $name}}) RETURN m.name, m.abundance", "params": {{"name": "Bacteroides_vulgatus"}}}}'
                 Use the provided schema: {GRAPH_SCHEMA_DESCRIPTION}
                 """,
            backstory="You are a bioinformatician specializing in graph databases. You have deep knowledge of the specific microbial interaction graph schema "
                      "and excel at translating natural language questions about microbes, metabolites, and pathways into effective Cypher queries.",
            tools=[get_graph_schema_tool], # Optional: Allow dynamic schema fetching
            llm=self.llm,
            verbose=True,
            memory=True,
            allow_delegation=False # This agent should focus solely on query generation
        )

        self.information_retriever = Agent(
            role="Neo4j Database Query Executor",
            goal="Execute the provided Cypher query using the 'Execute Cypher Query Tool' and return the raw results or error message.",
            backstory="You are a database operator responsible for safely and efficiently executing queries against the Neo4j knowledge graph. "
                      "You only execute the queries given to you and pass back the results directly.",
            tools=[execute_cypher_query_tool],
            llm=self.llm,
            verbose=True,
            memory=False, # Doesn't need memory of past *results*, just the query to execute
            allow_delegation=False
        )

        self.contextual_analyzer = Agent(
            role="Microbial Ecology Data Analyst",
            goal=f"""
                 Analyze the data retrieved from the knowledge graph (provided in the context)
                 in light of the original user query (also provided). Synthesize the findings,
                 identify key patterns (e.g., important producers/consumers, high flux interactions, common pathways),
                 and explain the potential biological significance or implications.
                 If the data indicates an error or no results were found, state that clearly.
                 Use the schema context if needed: {GRAPH_SCHEMA_DESCRIPTION}
                 """,
            backstory="You are a microbial ecologist with expertise in interpreting metabolic network data. "
                      "You can take raw graph query results and explain what they mean in a biological context, "
                      "answering the user's specific questions and providing relevant insights.",
            tools=[], # Analyzer interprets data, doesn't query again
            llm=self.llm,
            verbose=True,
            memory=True # Needs memory to relate results back to the query
        )

        self.report_writer = Agent(
            role="Scientific Report Writer",
            goal="Compile the analysis findings into a clear, concise, and well-structured report answering the original user query.",
            backstory="You are a scientific communicator skilled at summarizing complex analytical results "
                      "into an easily understandable report format, suitable for researchers or informed users.",
            tools=[],
            llm=self.llm,
            verbose=True,
            memory=False # Only needs the final analysis to write the report
        )

        self.agents = [
            self.query_constructor,
            self.information_retriever,
            self.contextual_analyzer,
            self.report_writer
        ]

    def run_analysis(self, user_query: str) -> str:
        """Runs the microbial community analysis pipeline for a given user query."""

        logger.info(f"Starting analysis pipeline for query: '{user_query}'")

        # Define tasks with clear dependencies and expected outputs
        construct_query_task = Task(
            description=f"""
                1. Analyze the user query: '{user_query}'
                2. Consult the graph schema (provided in your goal or use the schema tool if needed).
                3. Formulate the optimal Cypher query to answer the query.
                4. Output the query and any parameters as a JSON string.
                """,
            expected_output="A JSON string containing the 'query' and 'params' keys (e.g., '{\"query\": \"MATCH ...\", \"params\": {...}}').",
            agent=self.query_constructor
        )

        retrieve_data_task = Task(
            description="""
                1. Take the JSON string output from the previous task.
                2. Use the 'Execute Cypher Query Tool' to run the query against the database.
                3. Output the raw results (list of dictionaries) or the error dictionary returned by the tool.
                """,
            expected_output="A list of dictionaries representing the query results, or a dictionary containing an 'error' key.",
            agent=self.information_retriever,
            context=[construct_query_task] # Depends on the query output
        )

        analyze_results_task = Task(
            description=f"""
                1. Review the original user query: '{user_query}'
                2. Examine the data retrieved (or error message) from the previous task.
                3. If data exists, analyze it:
                    - Identify key microbes, metabolites, pathways mentioned or relevant.
                    - Describe the relationships found (production, consumption, cross-feeding, pathway involvement).
                    - Quantify findings using flux, abundance, or scores where available.
                    - Discuss potential biological implications or answer the specific question asked.
                4. If an error occurred or no data was found, clearly state this.
                5. Provide a detailed textual analysis.
                """,
            expected_output="A comprehensive textual analysis of the query results in the context of the user query, or a statement indicating missing data or errors.",
            agent=self.contextual_analyzer,
            context=[retrieve_data_task] # Depends on the retrieved data
        )

        write_report_task = Task(
            description="""
                1. Take the textual analysis from the previous task.
                2. Synthesize the key findings into a concise and well-structured final report.
                3. Ensure the report directly addresses the original user query.
                4. Format the report clearly (e.g., using markdown).
                """,
            expected_output="A final, formatted report summarizing the analysis and answering the user query.",
            agent=self.report_writer,
            context=[analyze_results_task] # Depends on the analysis
        )

        # Create and run the crew
        crew = Crew(
            agents=self.agents,
            tasks=[construct_query_task, retrieve_data_task, analyze_results_task, write_report_task],
            verbose=True # Use verbose=2 for detailed step-by-step logging
        )

        logger.info("Kicking off the Crew...")
        try:
            result = crew.kickoff()
            logger.info("Crew execution finished.")
            return result
        except Exception as e:
            error_message = f"Critical error running the Crew: {e}"
            logger.exception(error_message) # Log the full traceback
            return error_message


# --- Execution ---
if __name__ == "__main__":
    pipeline = None
    try:
        # Ensure Neo4j connection works before initializing the pipeline
        Neo4jKnowledgeGraph.get_driver(NEO4J_URI, NEO4J_USER, NEO4J_PASSWORD)

        pipeline = MicrobialAnalysisPipeline()

        # Example queries:
        # query1 = "Which microbes produce Butyrate with the highest flux?"
        # query2 = "Show me the interactions between Bacteroides_thetaiotaomicron and Eubacterium_rectale."
        # query3 = "What are the main producers and consumers of Acetate? Compare their abundance if available."
        # query4 = "Find pathways associated with Faecalibacterium_prausnitzii and list their importance scores."
        # query5 = "Tell me about Propionate - which microbes handle it?" # More open-ended
        query6 = "What microbes both produce and consume Thiamine? What is the net flux if possible?" # Requires more complex query/analysis


        selected_query = query6 # Choose the query to run

        print(f"\n--- Running Analysis for Query: ---\n{selected_query}\n" + "-"*35)
        start_time = time.time()
        result_object = pipeline.run_analysis(selected_query)
        end_time = time.time()
        print(f"\n--- Analysis Complete (Duration: {end_time - start_time:.2f} seconds) ---")

        # --- Output ---
        # Access the raw string output from the result object
        final_report_str = ""
        if result_object:
            # Check common attributes for the final string output
            if hasattr(result_object, 'raw') and isinstance(result_object.raw, str):
                final_report_str = result_object.raw
            elif isinstance(result_object, str): # Fallback if it somehow returned a string directly
                final_report_str = result_object
            else:
                # If neither .raw nor a direct string, convert the object to string representation
                # This might include extra details, but is better than erroring out.
                logger.warning("Could not find .raw attribute on CrewOutput, converting result object to string.")
                final_report_str = str(result_object)
        else:
            final_report_str = "Error: Crew execution did not return a result."


        print("\n--- Final Report ---")
        print(final_report_str)
        print("--------------------")

        # Save the report to a file
        try:
            with open("analysis_report.md", "w", encoding="utf-8") as f:
                f.write(f"# Analysis Report for Query:\n\n> {selected_query}\n\n")
                f.write(final_report_str)
            logger.info(f"Report saved to analysis_report.md")
        except Exception as e:
            logger.error(f"Error saving report to file: {e}")

    except Exception as e:
        logger.critical(f"An error occurred during setup or execution: {e}")
    finally:
        # Close Neo4j connection cleanly
        Neo4jKnowledgeGraph.close_driver()
        logger.info("Pipeline finished.")